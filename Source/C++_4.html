<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C++高频面经（四）之C++11新特性</title>
    <style>
        /* PC端样式 */
@media (min-width: 769px) {
 pre {
background-color: #f4f4f4;
padding: 10px;
border: 1px solid #ccc;
overflow: auto;
line-height: 1.5; /* 调整行距，这里设置为1.5倍行距 */
font-size: 16px; /* 调整字体大小，这里设置为16px，您可以根据需要修改 */
}
h1 {
 color: #007bff;
}
table {
 width: 60%; /* 表格宽度 */
 border-collapse: collapse; /* 合并边框 */
 font-family: Arial, sans-serif; /* 字体 */
}
th, td {
 border: 1px solid #ddd; /* 边框颜色 */
 padding: 10px; /* 内边距 */
 text-align: center; /* 文字居中 */
}
th {
 background-color: #4CAF50; /* 表头背景颜色 */
 color: white; /* 表头文字颜色 */
}
tr:nth-child(even) {
 background-color: #f2f2f2; /* 偶数行背景颜色 */
}
tr:hover {
 background-color: #ddd; /* 鼠标悬停行的背景颜色 */
}
li {
margin-bottom: 10px; /* 列表项之间的行距 */
}
}

/* 手机端样式 */
@media (max-width: 768px) {
pre {
background-color: #f4f4f4;
padding: 10px;
border: 1px solid #ccc;
overflow: auto;
font-size: 12px;
}
h1 {
 color: #007bff;
 font-size: 30px;
}
h2{
 font-size: 24px;
}
h3{
 font-size: 17px;

}
p{
 font-size: 14px;
}
table {
 width: 100%; /* 表格宽度 */
 border-collapse: collapse; /* 合并边框 */
 font-family: Arial, sans-serif; /* 字体 */
 font-size: 14px;
}
th, td {
 border: 1px solid #ddd; /* 边框颜色 */
 padding: 10px; /* 内边距 */
 text-align: center; /* 文字居中 */
}
th {
 background-color: #4CAF50; /* 表头背景颜色 */
 color: white; /* 表头文字颜色 */
}
tr:nth-child(even) {
 background-color: #f2f2f2; /* 偶数行背景颜色 */
}
tr:hover {
 background-color: #ddd; /* 鼠标悬停行的背景颜色 */
}
li {
margin-bottom: 10px; /* 列表项之间的行距 */
font-size: 12px;

}
}

</style> 
</head>
<body>
    <h1>C++面试高频（四）之C++11新特性</h1>

    <h2>1. 简述C++11有什么新特性？⭐⭐⭐</h2>
    <ul>
        <li><strong>自动类型推导（Type Inference）：</strong>引入了 <code>auto</code> 关键字，允许编译器根据初始化表达式的类型自动推导变量的类型。</li>
        <li><strong>统一的初始化语法（Uniform Initialization Syntax）：</strong>引入了用花括号 <code>{}</code> 进行初始化的统一语法，可以用于初始化各种类型的对象，包括基本类型、数组、结构体、类等。</li>
        <li><strong>右值引用（Rvalue References）：</strong>引入了 <code>&amp;&amp;</code> 符号，用于声明右值引用。右值引用具有区分左值和右值的能力，提供了移动语义和完美转发的基础。</li>
        <li><strong>移动语义（Move Semantics）：</strong>通过右值引用和移动构造函数实现，用于高效地转移资源拥有权，避免不必要的复制和内存分配。</li>
        <li><strong>lambda 表达式（Lambda Expressions）：</strong>引入了类似于匿名函数的语法，允许在代码中创建匿名函数对象，方便地编写更简洁的、具有局部作用域的函数。</li>
        <li><strong>并发支持（Concurrency Support）：</strong>引入了多线程和原子操作的支持，包括线程库、原子类型、互斥锁、条件变量等，使得并发编程更加方便和安全。</li>
        <li><strong>新的智能指针（Smart Pointers）：</strong>引入了 <code>std::shared_ptr</code>、<code>std::unique_ptr</code>、<code>std::weak_ptr</code> 等智能指针类模板，提供了更安全、更方便的内存管理机制。</li>
        <li><strong>静态断言（Static Assert）：</strong>引入了 <code>static_assert</code> 关键字，允许在编译时对表达式进行静态断言，用于自定义的编译时检查和错误提示。</li>
        <li><strong>新的标准库组件：</strong>包括了正则表达式库、基于范围的循环、哈希表（<code>std::unordered_map</code>、<code>std::unordered_set</code>）、随机数库、异步任务库（<code>std::async</code>）、类型特征工具。</li>
    </ul>

    <h2>2. auto关键字⭐⭐⭐⭐</h2>
    <p>auto是 C++ 中的关键字，用于自动推导变量的类型。它可以让编译器根据初始化表达式的类型自动推导变量的类型，从而简化类型的声明和定义过程。</p>
    <h3>优点：</h3>
    <ul>
        <li>简化类型声明：使用 <code>auto</code> 可以简化变量类型的声明，避免重复书写冗长的类型名。</li>
        <li>增强代码灵活性：使用 <code>auto</code> 可以方便地适应不同的数据类型，使代码更具有通用性和灵活性。</li>
        <li>减少代码依赖：使用 <code>auto</code> 可以减少对具体类型的依赖，使得代码的维护和修改更加灵活和容易。</li>
    </ul>
    <h3>缺点：</h3>
    <ul>
        <li>降低可读性：使用 <code>auto</code> 可能会降低代码的可读性，因为类型信息不再明显可见，需要根据上下文推测变量的真实类型。</li>
        <li>可能引发隐式类型转换：使用 <code>auto</code> 会自动推导变量的类型，可能导致隐式类型转换和意外的行为，尤其是在复杂的表达式或函数中使用时需要特别注意。</li>
    </ul>
    <h3>使用场景：</h3>
    <ul>
        <li>简化类型声明：在变量的类型已经明确而且易于推导的情况下，可以使用 <code>auto</code> 以简化代码。</li>
        <li>模板编程：在模板函数和模板类的定义中，通过 <code>auto</code> 结合类型推导，可以实现更通用、灵活的模板代码。</li>
        <li>迭代器类型：对于容器和遍历器等情况，使用 <code>auto</code> 可以自动推导迭代器的类型，避免显式指定具体类型。</li>
    </ul>
    <h3>代码示例：</h3>
    <pre><code>auto i = 10; // 推导为 int 类型
auto d = 3.14; // 推导为 double 类型
auto b = true; // 推导为 bool 类型

template &lt;typename T&gt;
auto add(T a, T b) -&gt; decltype(a + b) {
    return a + b;
}

std::vector&lt;int&gt; nums = {1, 2, 3, 4, 5};
for (auto it = nums.begin(); it != nums.end(); ++it) {
    std::cout &lt;&lt; *it &lt;&lt; " ";
}
</code></pre>
<h2>代码示例：</h2>
<h3>简化类型声明：</h3>
<pre><code>auto i = 10; // 推导为 int 类型
auto d = 3.14; // 推导为 double 类型
auto b = true; // 推导为 bool 类型
</code></pre>

<h3>模板函数和模板类的定义：</h3>
<pre><code>template &lt;typename T&gt;
auto add(T a, T b) -&gt; decltype(a + b) {
    return a + b;
}
</code></pre>

<h3>迭代器类型推导：</h3>
<pre><code>std::vector&lt;int&gt; nums = {1, 2, 3, 4, 5};
for (auto it = nums.begin(); it != nums.end(); ++it) {
    std::cout &lt;&lt; *it &lt;&lt; " ";
}
</code></pre>

<h2>3. Lambda表达式⭐⭐</h2>
<p>lambda 表达式的基本语法如下：</p>
<pre><code>[capture](parameters) -&gt; return_type { body }</code></pre>
<p>其中：</p>
<ul>
    <li><strong>capture：</strong>用于从外部作用域捕获变量，可以是值捕获或引用捕获。</li>
    <li><strong>parameters：</strong>函数参数列表。</li>
    <li><strong>return_type：</strong>函数返回类型。可以省略，会根据返回表达式自动推导。</li>
    <li><strong>body：</strong>函数体，可以包含任意合法的代码。</li>
</ul>

<h3>lambda优点：</h3>
<ul>
    <li>简洁性：lambda 表达式可以在需要时直接在代码中定义，避免了显式地编写独立的函数。</li>
    <li>局部性：lambda 表达式在定义它的作用域内有效，对于一些只在某个特定场景下使用的函数，使用 lambda 表达式更加合适。</li>
    <li>便捷性：lambda 表达式可以捕获外部作用域的变量，方便实现闭包效果，减少了函数参数的传递复杂性。</li>
</ul>

<h3>lambda缺点：</h3>
<ul>
    <li>可读性：lambda 表达式的语法相对复杂，对于不熟悉 lambda 表达式的人来说，可读性可能会有一定的挑战。</li>
    <li>滥用问题：在不需要捕获外部变量或需要较长代码块的场景下，过度使用 lambda 表达式可能会导致代码的可读性和可维护性下降。</li>
</ul>

<h3>使用场景：</h3>
<ul>
    <li>算法函数对象：作为 STL 的算法函数对象，lambda 表达式可以方便地用于操作容器中的元素。</li>
    <li>回调函数：作为回调函数传递给其他函数，lambda 表达式可以提供一种简洁的实现方式。</li>
    <li>并行编程：在并行编程的场景下，lambda 表达式可以用于定义线程函数或并行执行的任务。</li>
</ul>

<h3>作为算法函数对象：</h3>
<pre><code>std::vector&lt;int&gt; nums = {1, 2, 3, 4, 5};
std::for_each(nums.begin(), nums.end(), [](int num) {
    std::cout &lt;&lt; num &lt;&lt; " ";
});
</code></pre>

<h3>作为回调函数：</h3>
<pre><code>void doSomething(int a, int b, std::function&lt;int(int, int)&gt; callback) {
    int result = callback(a, b);
    std::cout &lt;&lt; "Result: " &lt;&lt; result &lt;&lt; std::endl;
}

doSomething(5, 3, [](int x, int y) {
    return x + y;
});
</code></pre>

<h3>并行编程：</h3>
<pre><code>std::vector&lt;int&gt; nums = {1, 2, 3, 4, 5};
std::vector&lt;int&gt; squares(nums.size());

#pragma omp parallel for
for (size_t i = 0; i &lt; nums.size(); ++i) {
    squares[i] = nums[i] * nums[i];
}
</code></pre>

<h2>4. 理解左值和右值⭐⭐⭐⭐</h2>
<h3>左值（L-value）：</h3>
<p>左值表示一个内存位置的标识符，可以出现在赋值语句的左边或右边。左值在表达式中是持久的，具有地址，并且可以被修改。可以将其简单理解为"可以取址的表达式"。一般来说，变量、函数或内存中的对象都可以是左值。</p>

<h3>右值（R-value）：</h3>
<p>右值表示暂时的、临时的值，不能出现在赋值语句的左边。右值在表达式中是短暂的，不具有地址，不能被修改。可以将其简单理解为"没有地址的表达式"。一般来说，常量、字面量、临时对象、表达式的结果等都可以被视为右值。</p>

<h3>举例来说：</h3>
<pre><code>int x = 10; // x 是一个左值，可以取址和修改
int y = x; // x 是一个右值，不可以取址，只是一个临时值
int z = x + y; // x + y 是一个右值，表达式计算结果是一个临时值
</code></pre>

<h2>5. 什么是右值引用？它的作用？⭐⭐</h2>
<p>右值引用（R-value reference）是 C++11 引入的一种新的引用类型，用于标识和操作右值。</p>
<p>右值引用使用 <code>&amp;&amp;</code> 符号进行声明，例如 <code>int&&</code> 表示一个右值引用类型的整数。右值引用具有以下几个重要的特性和作用：</p>

<ul>
    <li><strong>标识右值：</strong>右值引用主要用于标识和操作右值（临时值、表达式结果、将被销毁的值等）。右值引用只能绑定到右值，不能绑定到左值。</li>
    <li><strong>移动语义：</strong>右值引用支持移动语义，通过对临时对象的资源所有权进行移动而不是复制，提高了操作的效率。例如，在对象的拷贝构造函数和拷贝赋值运算符中，可以通过移动构造函数和移动赋值运算符来实现对资源的转移。</li>
    <li><strong>完美转发：</strong>右值引用也用于实现完美转发，即在函数模板中保持参数的值类别。通过使用右值引用参数，可以将传递给函数的右值或左值转发到其他函数，保持传递参数的原始值类别。</li>
</ul>

<p>右值引用的作用主要体现在以下几个方面：</p>
<ul><strong>
    <li>避免不必要的拷贝：通过标识和操作右值，可以避免在操作临时对象时进行不必要的拷贝操作，提高程序的性能。</li>
    <li>实现移动语义：通过右值引用和移动操作，可以在对象的资源拷贝过程中，将资源所有权从一个对象转移给另一个对象，避免了不必要的资源拷贝。</li>
    <li>支持完美转发：通过右值引用，可以保持传递参数的值类别，实现参数的完美转发，避免了临时对象的额外拷贝操作。</li>
</strong>
</ul>

<p>以下是一个简单示例，展示了右值引用的使用：</p>
<pre><code>void processValue(int&& value) {
    // 对右值进行操作
    // ...
}

int main() {
    int x = 10;

    processValue(5); // 临时值 5 是一个右值
    processValue(x); // x 是一个左值，无法绑定到右值引用

    return 0;
}
</code></pre>

<p>在这个示例中，<code>processValue()</code> 函数接受一个右值引用参数，可以绑定到临时值 5，但无法绑定到变量 x。右值引用可以用于对右值进行特定的操作，提高代码的效率和灵活性。</p>
<h2>6. 说说移动语义的原理⭐</h2>
<p>移动语义：移动语义为了避免临时对象的拷贝，将内存的所有权从一个对象转移到另外一个对象，高效的移动用来替换效率低下的复制，为类增加移动构造函数。移动构造函数与拷贝构造不同，它并不是重新分配一块新的空间同时将要拷贝的对象复制过来，而是"拿"了过来，将自己的指针指向别人的资源，然后将别人的指针修改为nullptr。</p>
<img src="../image/C++4.png"  style="max-width: 100%; height: auto;">

<h3>代码举例：</h3>
<pre><code>class MyObject {
public:
    // 移动构造函数
    MyObject(MyObject&& other) noexcept {
        // 将资源从 other 移动到当前对象
        data_ = other.data_;
        other.data_ = nullptr;
    }
    
    // 移动赋值运算符
    MyObject& operator=(MyObject&& other) noexcept {
        // 检查自我赋值
        if (this == &other) {
            return *this;
        }
        
        // 释放当前对象的资源
        delete data_;
        
        // 将资源从 other 移动到当前对象
        data_ = other.data_;
        other.data_ = nullptr;
        
        return *this;
    }
    
private:
    int* data_;  // 动态分配的内存资源
};</code></pre>
<p>当需要移动一个 MyObject 对象时，移动构造函数将获取 other 对象的资源，并将 other 的指针置为 nullptr。移动赋值运算符也类似，先释放当前对象的资源，再将 other 的资源移动到当前对象。</p>

<h2>7. 说说完美转发的原理⭐⭐</h2>
<p>完美转发（Perfect Forwarding）是 C++ 中用来保持传递参数的值类别的技术，它使得函数模板在接受参数时能够保持传递参数的原始值类别，无论是左值还是右值。</p>
<p>完美转发的原理是基于引用折叠（Reference collapsing）和函数重载解析。引用折叠是一种规则，用于在特定情况下将引用类型折叠为一个类型。在函数重载解析过程中，编译器会根据参数的值类别和函数模板的特化匹配最佳的函数。</p>
<p>为了实现完美转发，通常要使用两个重要的特性：</p>
<ul>
    <li><strong>模板类型推导：</strong>函数模板使用模板参数来承载传递的参数，通过类型推导来确定参数的类型。</li>
    <li><strong>转发引用：</strong>转发引用是指使用 std::forward 函数来将参数转发给其他函数。std::forward 的原理是根据参数的值类别和是否为左值引用来决定将参数转发为左值引用或右值引用。</li>
</ul>

<h3>下面是一个简单的示例来说明完美转发的原理：</h3>
<pre><code>template &lt;typename T&gt;
void process(T&& arg) {
    otherFunction(std::forward&lt;T&gt;(arg));
}

void otherFunction(int& arg) {
    std::cout &lt;&lt; "L-value reference: " &lt;&lt; arg &lt;&lt; std::endl;
}

void otherFunction(int&& arg) {
    std::cout &lt;&lt; "R-value reference: " &lt;&lt; arg &lt;&lt; std::endl;
}

int main() {
    int x = 10;

    process(x); // 传递左值，调用 L-value 引用版本
    process(5); // 传递右值，调用 R-value 引用版本

    return 0;
}
</code></pre>
<p>在上面的示例中，process 函数是一个模板，并使用转发引用将参数 arg 转发给 otherFunction 函数。由于完美转发的存在，模板类型推导保持了参数的原始值类别，通过重载解析选取对应的函数版本进行调用。</p>

<h2>8. 请你说说函数模板与模板函数？⭐⭐⭐</h2>
<strong><p>函数模板是一种通用的函数模板声明，其中函数的参数和返回类型可以使用通用的模板参数来表示。函数模板的定义通常以 <code>template&lt;typename T&gt;</code> 或 <code>template&lt;class T&gt;</code> 开始，后跟函数的声明或定义。</p></strong>
<p>下面是一个简单的函数模板的示例：</p>
<pre><code>template&lt;typename T&gt;
T add(T a, T b) {
    return a + b;
}

int intResult = add(5, 10);         // 实例化为 add&lt;int&gt;(5, 10)，返回 15
double doubleResult = add(3.14, 2.71);  // 实例化为 add&lt;double&gt;(3.14, 2.71)，返回 5.85
<p>在这个例子中，add 是一个函数模板，它可以接受相同类型的参数 a 和 b，并返回它们的和。模板参数 T 是一个占位符，表示函数中的类型。在函数调用时，编译器会根据实际的参数类型来实例化函数模板。</p>
</code></pre>
<strong>
<p>模板函数（Template function specialization）是对特定模板参数进行特化的函数定义。特化是指针对特定的模板参数类型编写的特殊版本。特化函数可以提供对特定数据类型的定制化行为。</p>
</strong>
<p>下面是一个函数模板特化的示例：</p>
<pre><code>template&lt;typename T&gt;
T max(T a, T b) {
    return (a &gt; b) ? a : b;
}

template&lt;&gt;
const char* max&lt;const char*&gt;(const char* a, const char* b) {
    return strcmp(a, b) &gt; 0 ? a : b;
}
</code></pre>
<p>在这个例子中，max 是一个函数模板，用于比较两个值并返回较大的值。然后，通过模板特化 <code>template&lt;&gt;</code> 来定义 max 函数针对 <code>const char*</code> 类型的特殊版本。这个特殊版本使用了 strcmp 函数来比较两个 C 字符串并返回较大的字符串。</p>
<h3>不同点：</h3>
<ul>
    <li>函数模板是一个通用的模板声明，可以用于多种数据类型，根据实际参数类型来实例化。</li>
    <li>模板函数是对特定模板参数进行特化的函数定义，提供了对特定数据类型的定制化行为。</li>
</ul>
<h2>9. 智能指针⭐⭐⭐⭐⭐</h2>
<p>智能指针是C++中用于管理动态分配对象的一种特殊指针，它能够自动地分配和释放内存，避免内存泄漏和悬挂指针的问题。常用的智能指针有 <code>unique_ptr</code>、<code>shared_ptr</code> 和 <code>weak_ptr</code> 以及 <code>auto_ptr</code>（已弃用）。</p>

<h3>unique_ptr</h3>
<ul>
    <li>nique_ptr 是独占所有权的智能指针，用于管理动态分配的对象。</li>
    <li>它禁止多个unique_ptr 指向同一对象，可以通过 <code>std::move</code> 转移所有权。</li>
    <li>适用于需要独占所有权的场景，能够避免内存泄漏。</li>
</ul>
<p>unique指针规定一个智能指针独占一块内存资源。当两个智能指针同时指向一块内存，编译报错。我们只需要将拷贝构造函数和赋值拷贝构造函数申明为private或delete。不允许拷贝构造函数和赋值操作符。</p>

<h4>代码举例：</h4>
<pre><code>#include &lt;iostream&gt;
#include &lt;memory&gt;

int main() {
    std::unique_ptr&lt;int&gt; uniquePtr(new int(10));
    if (uniquePtr) {
        std::cout &lt;&lt; *uniquePtr &lt;&lt; std::endl; // 输出10
    }
    uniquePtr.reset(); // 手动释放内存
    return 0;
}
</code></pre>

<h3>shared_ptr</h3>
<ul>
    <li><code>shared_ptr</code> 允许多个指针共享对同一对象的所有权，通过引用计数来追踪当前有多少个指针共享一个对象。</li>
    <li>当最后一个 <code>shared_ptr</code> 超出作用域或被重置时，才会释放所管理的对象。</li>
    <li>它可以通过 <code>std::make_shared</code> 来创建，并且允许拷贝和移动。</li>
</ul>
<p>相关问题: <code>shared_ptr</code> 出现内存泄露怎么办？</p>
<p>共享指针的循环引用计数问题：当两个类中相互定义 <code>shared_ptr</code> 成员变量，同时对象相互赋值时，就会产生循环引用计数问题，最后引用计数无法清零，资源得不到释放。</p>
<p>可以使用 <code>weak_ptr</code>，<code>weak_ptr</code> 是弱引用，<code>weak_ptr</code> 的构造和析构不会引起引用计数的增加或减少。我们可以将其中一个改为 <code>weak_ptr</code> 指针就可以了。</p>

<h4>代码举例：</h4>
<pre><code>#include &lt;iostream&gt;
#include &lt;memory&gt;

int main() {
    std::shared_ptr&lt;int&gt; sharedPtr1 = std::make_shared&lt;int&gt;(10);
    std::shared_ptr&lt;int&gt; sharedPtr2 = sharedPtr1;

    std::cout &lt;&lt; *sharedPtr1 &lt;&lt; " " &lt;&lt; *sharedPtr2 &lt;&lt; std::endl; // 输出10 10

    sharedPtr1.reset(); // 释放sharedPtr1所指向的对象

    if (sharedPtr2) {
        std::cout &lt;&lt; *sharedPtr2 &lt;&lt; std::endl; // 输出10
    }

    return 0;
}
</code></pre>

<h3>weak_ptr</h3>
<p><code>weak_ptr</code> 是一种不共享所有权的智能指针，用于解决 <code>shared_ptr</code> 的循环引用问题。</p>
<p><code>weak_ptr</code> 可以从 <code>shared_ptr</code> 创建，但不能直接访问所管理的对象。</p>
<p>它可以使用 <code>lock()</code> 方法来获取一个有效的 <code>shared_ptr</code>，用于访问所管理的对象。</p>

<h4>举例代码：</h4>
<pre><code>#include &lt;iostream&gt;
#include &lt;memory&gt;

int main() {
    std::shared_ptr&lt;int&gt; sharedPtr = std::make_shared&lt;int&gt;(10);
    std::weak_ptr&lt;int&gt; weakPtr(sharedPtr);

    if (auto lockedPtr = weakPtr.lock()) {
        std::cout &lt;&lt; *lockedPtr &lt;&lt; std::endl; // 输出10
    }

    sharedPtr.reset(); // 释放sharedPtr，引用计数为0

    if (weakPtr.expired()) {
        std::cout &lt;&lt; "Weak pointer expired" &lt;&lt; std::endl;
    }

    return 0;
}
</code></pre>

<h2>10. 四种cast转换⭐⭐⭐</h2>
<p>C++中有四种类型转换符可用于在不同类型之间进行类型转换：<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code> 和 <code>reinterpret_cast</code>。</p>

<h3>static_cast：</h3>
<ul>
    <li>基本类型之间的转换，例如将 <code>int</code> 转换为 <code>double</code> 等。</li>
    <li>向上或向下进行继承关系的指针或引用转换。</li>
    <li>显式调用转换构造函数或转换操作符。</li>
    <li>进行其他合法的转换，例如指针与整数类型之间的转换。</li>
</ul>
<p>示例：</p>
<pre><code>int num = 10;
double convertedNum = static_cast&lt;double&gt;(num);

class Base {};
class Derived : public Base {};
Base* basePtr = new Derived();
Derived* derivedPtr = static_cast&lt;Derived*&gt;(basePtr);
</code></pre>

<h3>dynamic_cast：</h3>
<ul>
    <li>向上转换：将派生类指针或引用转换为基类指针或引用。</li>
    <li>安全向下转换：将基类指针或引用转换为派生类指针或引用，仅当基类指针或引用实际指向派生类对象时才有效。</li>
    <li>运行时类型检查：<code>dynamic_cast</code> 会在运行时检查转换的安全性，如果转换失败，返回空指针（对于指针转换）或抛出 <code>std::bad_cast</code> 异常（对于引用转换）。</li>
</ul>
<p>示例：</p>
<pre><code>class Base { virtual void foo() {} };
class Derived : public Base {};

Base* basePtr = new Derived();
Derived* derivedPtr = dynamic_cast&lt;Derived*&gt;(basePtr);
if (derivedPtr) {
    // 转换成功
}
</code></pre>

<h3>const_cast：</h3>
<p><code>const_cast</code> 用于去除指针或引用的 <code>const</code> 属性。</p>
<ul>
    <li>可以修改被 <code>const</code> 修饰的对象。</li>
    <li>仅能去除直接指针或引用的 <code>const</code> 属性。</li>
    <li>使用 <code>const_cast</code> 需谨慎，因为修改被 <code>const</code> 修饰的对象会导致未定义行为。仅在确保安全性的前提下使用。</li>
</ul>
<p>示例：</p>
<pre><code>const int num = 10;
int* nonConstPtr = const_cast&lt;int*&gt;(&num);
*nonConstPtr = 20; // 合法：修改nonConstPtr的值
</code></pre>

<h3>reinterpret_cast：</h3>
<p><code>reinterpret_cast</code> 是 C++ 中用于执行低级别的类型转换的关键字（使用 <code>reinterpret_cast</code> 需要格外谨慎）。</p>
<ul>
    <li>它可以将一个指针或引用转换为不同类型的指针或引用，甚至是完全无关的类型。</li>
    <li><code>reinterpret_cast</code> 在类型转换时只进行位模式的重新解释，不执行任何类型检查或转换操作。</li>
    <li>错误的使用 <code>reinterpret_cast</code> 可能导致程序行为不确定或非法。</li>
    <li>因此，除非绝对必要，否则应避免使用 <code>reinterpret_cast</code>，并且使用前需要确保类型转换的合法性。</li>
</ul>
<p>示例代码：</p>
<pre><code>int num = 10;
    double* doublePtr = reinterpret_cast<double*>(&num);  // 不安全，可能导致未定义行为
    int* intPtr = reinterpret_cast<int*>(doublePtr);  // 转回原始类型
    </code></pre>
